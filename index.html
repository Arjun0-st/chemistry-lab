<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chemistry Lab Sim: AI Powered</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #2c3e50;
            user-select: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        #header {
            text-align: center;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            padding: 10px;
            align-self: center;
        }

        h1 { margin: 0; font-size: 2rem; }
        p { margin: 5px 0; font-size: 1rem; color: #bdc3c7; }

        #controls {
            pointer-events: auto;
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        button {
            padding: 12px 24px;
            font-size: 1.2rem;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.1s, background 0.2s;
        }

        #reset-btn { background-color: #e74c3c; color: white; }
        #reset-btn:hover { background-color: #c0392b; }
        
        #suggest-btn { background-color: #8e44ad; color: white; }
        #suggest-btn:hover { background-color: #732d91; }

        #instruction-box {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            max-width: 320px;
            pointer-events: auto;
            font-size: 0.85rem;
            line-height: 1.4;
            max-height: 300px;
            overflow-y: auto;
        }

        /* AI Chat Bubble Styles */
        #ai-bubble {
            position: absolute;
            bottom: 140px; /* Positioned near the boy character */
            left: 20px;
            max-width: 300px;
            background: white;
            color: #333;
            padding: 15px;
            border-radius: 15px;
            border-bottom-left-radius: 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            font-size: 0.95rem;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
            z-index: 20;
        }
        
        #ai-bubble.visible {
            opacity: 1;
            transform: translateY(0);
        }

        #ai-bubble strong {
            color: #8e44ad;
            display: block;
            margin-bottom: 5px;
        }

        #reaction-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #f1c40f;
            text-shadow: 0 0 10px red;
            opacity: 0;
            transition: opacity 0.5s;
            text-align: center;
            pointer-events: none;
            white-space: nowrap;
            z-index: 10;
        }

        .show-text { opacity: 1 !important; }
        
        .loading-dots:after {
            content: '.';
            animation: dots 1.5s steps(5, end) infinite;
        }
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60% { content: '...'; }
            80%, 100% { content: ''; }
        }

    </style>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div id="header">
            <h1>Advanced Chemistry Lab âœ¨</h1>
            <p>Powered by Gemini AI</p>
        </div>
        
        <div id="reaction-text">REACTION!</div>
        
        <!-- AI Response Bubble -->
        <div id="ai-bubble">
            <strong>Dr. Atom (AI):</strong>
            <span id="ai-content">Hello! Let your curiosity guide u.</span>
        </div>

        <div style="display:flex; justify-content: space-between; align-items: flex-end; width: 100%;">
            <div id="instruction-box">
                <strong>Inventory:</strong><br>
                Metals: Na, K, Li, Mg, Ca, Fe, Zn, Cu, Al, Pb<br>
                Liquids: H2O, HCl, H2SO4, HNO3, NaOH, KOH, Hg, CuSO4, Ethanol, NH3<br>
                <br>
                <em>Tip: Use the "Suggest Experiment" button to get ideas from AI!</em>
            </div>
            <div id="controls">
                <button id="suggest-btn">âœ¨ Suggest Experiment</button>
                <button id="reset-btn">Clean Beaker</button>
            </div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- CONFIG ---
        const SCENE_BG = 0x2c3e50;
        const TABLE_COLOR = 0x5D4037;
        // PASTE YOUR GEMINI API KEY HERE
        const apiKey = ""; 
        
        // --- GLOBALS ---
        let scene, camera, renderer, raycaster, mouse;
        let clock;
        let beaker, liquidMesh, gasMesh;
        let particles = [];
        let boyCharacter;
        let chemicals = []; 
        let beakerContents = []; 
        let isReacting = false;
        
        // --- CUSTOM AUDIO SETUP ---
        // INSTRUCTIONS:
        // 1. Put your audio files in the same folder as this index.html
        // 2. Change the filenames below (e.g., 'explosion': 'my_blast.mp3')
        // 3. Ensure your browser allows autoplay or interact with the page first
        const soundFiles = {
            'explosion': 'https://www.youtube.com/watch?v=YRex1Udiybs',
            'bubbles': 'https://actions.google.com/sounds/v1/water/bubbles.ogg',
            'steam': 'https://actions.google.com/sounds/v1/transportation/steam_train_whistle.ogg',
            'heavy_liquid': 'https://actions.google.com/sounds/v1/water/water_droplet.ogg'
        };

        function playSoundEffect(type) {
            const filePath = soundFiles[type];
            if (filePath) {
                const audio = new Audio(filePath);
                audio.volume = 0.6; // Adjust volume (0.0 to 1.0)
                // Browsers often block audio until user interaction. 
                // The game requires clicks to play, so this usually works.
                audio.play().catch(e => console.log("Audio play error (Check file path or browser permissions):", e));
            }
        }
        
        // Animation Helpers
        let activeAnimation = null;
        let pourStreamMesh = null;
        let dropMesh = null;
        
        // Audio Context for AI Voice (TTS)
        let audioContext;

        // --- INIT ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(SCENE_BG);
            scene.fog = new THREE.Fog(SCENE_BG, 15, 60);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 8, 18);
            camera.lookAt(0, 2, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            setupLights();
            createLabEnvironment();
            boyCharacter = createBoy();
            createChemicals();

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousedown', onMouseDown, false);
            window.addEventListener('touchstart', onTouchStart, false);
            document.getElementById('reset-btn').addEventListener('click', emptyBeaker);
            document.getElementById('suggest-btn').addEventListener('click', askForSuggestion);

            // Initialize Audio Context on user interaction (Required for modern browsers)
            window.addEventListener('click', () => {
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }, { once: true });

            clock = new THREE.Clock();
            
            // Initial greeting
            showAIBubble("Welcome to the lab! I'm Dr. Atom. Mix any metal with acid or water to see what happens!");
            
            animate();
        }

        function setupLights() {
            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambient);

            const spot = new THREE.SpotLight(0xffffff, 0.8);
            spot.position.set(10, 20, 10);
            spot.castShadow = true;
            spot.shadow.mapSize.width = 2048;
            spot.shadow.mapSize.height = 2048;
            scene.add(spot);
            
            const point = new THREE.PointLight(0x3498db, 0.2);
            point.position.set(0, 5, 0);
            scene.add(point);
        }

        // --- GEMINI API INTEGRATION ---

        async function generateContent(prompt) {
            if (!apiKey) {
                console.warn("API Key not found");
                return "Simulated AI Response: API Key missing.";
            }

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                if (!response.ok) throw new Error('API call failed');
                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
            } catch (error) {
                console.error("Gemini Error:", error);
                return "I couldn't analyze that reaction properly right now.";
            }
        }

        async function speakText(text) {
            if (!apiKey || !audioContext) return;
            if (audioContext.state === 'suspended') await audioContext.resume();

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: text }] }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: { voiceName: "Puck" }
                                }
                            }
                        }
                    })
                });

                if (!response.ok) throw new Error('TTS call failed');
                const data = await response.json();
                
                if (!data.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data) {
                    console.warn("No audio data returned");
                    return;
                }

                const audioContent = data.candidates[0].content.parts[0].inlineData.data;
                
                // Decode Base64
                const binaryString = atob(audioContent);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                playPCM(bytes.buffer);

            } catch (error) {
                console.warn("TTS Error:", error);
            }
        }

        function playPCM(arrayBuffer) {
            // Gemini TTS Defaults: 24kHz, 1 channel, 16-bit PCM
            const sampleRate = 24000; 
            const numChannels = 1;
            
            // Convert 16-bit PCM (Int16) to Float32 (-1.0 to 1.0)
            const dataView = new DataView(arrayBuffer);
            const numSamples = arrayBuffer.byteLength / 2;
            const float32Data = new Float32Array(numSamples);
            
            for (let i = 0; i < numSamples; i++) {
                // Little endian is standard for WAV/PCM
                const int16 = dataView.getInt16(i * 2, true); 
                // Normalize Int16 to Float32 range [-1.0, 1.0]
                float32Data[i] = int16 < 0 ? int16 / 32768 : int16 / 32767;
            }

            // Create AudioBuffer
            const audioBuffer = audioContext.createBuffer(numChannels, numSamples, sampleRate);
            audioBuffer.copyToChannel(float32Data, 0);

            // Play
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);
            source.start();
        }

        async function analyzeReaction(chemicals, type) {
            const bubble = document.getElementById('ai-content');
            bubble.innerHTML = "Analyzing reaction<span class='loading-dots'></span>";
            showAIBubble(null);

            let prompt = `You are a chemistry teacher explaining a reaction to a student.
            The student mixed: ${chemicals.join(', ')}.
            The observed result was: ${type}.
            Provide a 1-sentence fun explanation and the balanced chemical equation.
            Keep it very brief.`;

            const text = await generateContent(prompt);
            showAIBubble(text);
            speakText(text); 
        }

        async function askForSuggestion() {
            const bubble = document.getElementById('ai-content');
            bubble.innerHTML = "Thinking<span class='loading-dots'></span>";
            showAIBubble(null);

            const inventory = "Na, K, Li, Mg, Ca, Fe, Zn, Cu, Al, Pb, H2O, HCl, H2SO4, HNO3, NaOH, KOH, Hg, CuSO4, Ethanol, NH3";
            let prompt = `You are a lab assistant. The inventory is: ${inventory}.
            Suggest ONE cool, specific combination for the user to try in the beaker. 
            Mention what visual effect they will see (e.g. bubbles, explosion, color change).
            Keep it under 20 words.`;

            const text = await generateContent(prompt);
            showAIBubble(text);
        }

        function showAIBubble(text) {
            const bubble = document.getElementById('ai-bubble');
            if(text) document.getElementById('ai-content').innerText = text;
            bubble.classList.add('visible');
        }

        // --- ENVIRONMENT ---

        function createLabEnvironment() {
            // Floor
            const floorGeo = new THREE.PlaneGeometry(80, 80);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x34495e });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Table
            const tableGeo = new THREE.BoxGeometry(20, 0.5, 6);
            const tableMat = new THREE.MeshStandardMaterial({ color: TABLE_COLOR, roughness: 0.8 });
            const table = new THREE.Mesh(tableGeo, tableMat);
            table.position.y = 2;
            table.castShadow = true;
            table.receiveShadow = true;
            scene.add(table);

            // Legs
            const legGeo = new THREE.CylinderGeometry(0.3, 0.3, 2);
            const legMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            [[-9, 1, 2.5], [9, 1, 2.5], [-9, 1, -2.5], [9, 1, -2.5]].forEach(pos => {
                const leg = new THREE.Mesh(legGeo, legMat);
                leg.position.set(...pos);
                leg.castShadow = true;
                scene.add(leg);
            });

            // Shelves (Background)
            const shelfGeo = new THREE.BoxGeometry(20, 0.2, 2);
            const shelfMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
            
            // Shelf 1
            const s1 = new THREE.Mesh(shelfGeo, shelfMat);
            s1.position.set(0, 4.5, -4);
            s1.castShadow = true;
            scene.add(s1);
            
            // Shelf 2
            const s2 = new THREE.Mesh(shelfGeo, shelfMat);
            s2.position.set(0, 7.0, -4);
            s2.castShadow = true;
            scene.add(s2);

            // Beaker
            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff, transparent: true, opacity: 0.2,
                roughness: 0, metalness: 0.1, side: THREE.DoubleSide
            });
            
            // Beaker Body
            const beakerGeo = new THREE.CylinderGeometry(1.5, 1.5, 3, 32, 1, true);
            beaker = new THREE.Mesh(beakerGeo, glassMat);
            beaker.position.set(0, 3.55, 0); 
            scene.add(beaker);
            
            const beakerBot = new THREE.Mesh(new THREE.CircleGeometry(1.5, 32), glassMat);
            beakerBot.rotation.x = -Math.PI / 2;
            beakerBot.position.set(0, 2.06, 0); 
            scene.add(beakerBot);

            // Liquid Level (Hidden initially)
            const liquidGeo = new THREE.CylinderGeometry(1.4, 1.4, 1, 32);
            const liquidMat = new THREE.MeshPhysicalMaterial({ 
                color: 0x3498db, transparent: true, opacity: 0.7, 
                roughness: 0.1, metalness: 0.1, transmission: 0.2
            });
            liquidMesh = new THREE.Mesh(liquidGeo, liquidMat);
            liquidMesh.scale.y = 0; 
            liquidMesh.position.set(0, 2.06, 0); 
            liquidMesh.geometry.translate(0, 0.5, 0); // Pivot bottom
            liquidMesh.visible = false;
            scene.add(liquidMesh);

            // Gas Fill (Hidden initially)
            const gasGeo = new THREE.CylinderGeometry(1.4, 1.4, 2.9, 32);
            const gasMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.0 });
            gasMesh = new THREE.Mesh(gasGeo, gasMat);
            gasMesh.position.set(0, 3.55, 0);
            gasMesh.visible = false;
            scene.add(gasMesh);
        }

        function createLabel(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#f0f0f0'; ctx.fillRect(0,0,128,64);
            ctx.fillStyle = '#000'; ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, 64, 32);
            const map = new THREE.CanvasTexture(canvas);
            const mat = new THREE.MeshBasicMaterial({ map: map });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(0.7, 0.35), mat);
            return mesh;
        }

        // --- GEOMETRIES ---

        function createChunkGeometry() {
            const geo = new THREE.DodecahedronGeometry(0.3, 0);
            const pos = geo.attributes.position;
            for(let i=0; i<pos.count; i++){
                pos.setX(i, pos.getX(i) + (Math.random()-0.5)*0.1);
                pos.setY(i, pos.getY(i) + (Math.random()-0.5)*0.1);
                pos.setZ(i, pos.getZ(i) + (Math.random()-0.5)*0.1);
            }
            geo.computeVertexNormals();
            return geo;
        }

        function createRibbonGeometry() {
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(-0.2, 0, 0), new THREE.Vector3(-0.1, 0.2, 0.1),
                new THREE.Vector3(0.1, -0.2, -0.1), new THREE.Vector3(0.2, 0, 0)
            ]);
            return new THREE.TubeGeometry(curve, 20, 0.05, 8, false);
        }

        function createNailGeometry() {
            // Iron Nail
            const geo = new THREE.CylinderGeometry(0.04, 0.02, 0.6, 8);
            const head = new THREE.CylinderGeometry(0.1, 0.1, 0.02, 8);
            head.translate(0, 0.3, 0);
            geo.merge(head);
            return geo;
        }

        function createWireGeometry() {
            // Copper Wire coil
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(-0.15, -0.1, 0), new THREE.Vector3(0.15, 0, 0.1),
                new THREE.Vector3(-0.15, 0.1, 0), new THREE.Vector3(0.15, 0.2, -0.1)
            ]);
            return new THREE.TubeGeometry(curve, 30, 0.02, 8, false);
        }

        function createGranuleGeometry() {
            // Zinc granule (irregular small blob)
            const geo = new THREE.IcosahedronGeometry(0.15, 0);
            const pos = geo.attributes.position;
            for(let i=0; i<pos.count; i++){
                pos.setXYZ(i, pos.getX(i)*Math.random(), pos.getY(i)*Math.random(), pos.getZ(i)*Math.random());
            }
            geo.computeVertexNormals();
            return geo;
        }

        function createChemicals() {
            // Define Metals
            const metals = [
                { name: 'Na', label: 'Na', color: 0xbdc3c7, shape: 'nail' },
                { name: 'K', label: 'K', color: 0x95a5a6, shape: 'chunk' },
                { name: 'Li', label: 'Li', color: 0xdcdcdc, shape: 'chunk' },
                { name: 'Mg', label: 'Mg', color: 0xffffff, shape: 'ribbon' },
                { name: 'Ca', label: 'Ca', color: 0xbdc3c7, shape: 'granule' },
                { name: 'Fe', label: 'Fe Nails', color: 0x5c5c5c, shape: 'nail' },
                { name: 'Zn', label: 'Zn', color: 0xa8a8a8, shape: 'granule' },
                { name: 'Cu', label: 'Cu', color: 0xb87333, shape: 'wire' },
                { name: 'Al', label: 'Al Foil', color: 0xe0e0e0, shape: 'ribbon' }, 
                { name: 'Pb', label: 'Pb', color: 0x4a4a4a, shape: 'chunk' }
            ];

            // Define Liquids/Acids
            const liquids = [
                { name: 'H2O', label: 'Water', color: 0x3498db, opacity: 0.4 },
                { name: 'HCl', label: 'HCl', color: 0xffffcc, opacity: 0.3 }, 
                { name: 'H2SO4', label: 'H2SO4', color: 0xffffff, opacity: 0.6, viscous: true }, 
                { name: 'HNO3', label: 'HNO3', color: 0xffeb3b, opacity: 0.4 },
                { name: 'NaOH', label: 'NaOH', color: 0xecf0f1, opacity: 0.5 },
                { name: 'KOH', label: 'KOH', color: 0xecf0f1, opacity: 0.5 },
                { name: 'Hg', label: 'Mercury', color: 0xaaaaaa, opacity: 1.0, metallic: true },
                { name: 'CuSO4', label: 'CuSO4', color: 0x0000ff, opacity: 0.6 },
                { name: 'Ethanol', label: 'Ethanol', color: 0xffffff, opacity: 0.2 },
                { name: 'NH3', label: 'Ammonia', color: 0xf0f0f0, opacity: 0.3 }
            ];

            // Place Metals on Top Shelf
            metals.forEach((m, i) => {
                const mesh = createSolidContainer(m);
                mesh.position.set(-8 + (i * 1.8), 7.8, -4);
                mesh.userData = { def: { type: 'solid', ...m }, originalPos: mesh.position.clone() };
                scene.add(mesh);
                chemicals.push(mesh);
            });

            // Place Liquids on Lower Shelf
            liquids.forEach((l, i) => {
                const mesh = createLiquidBottle(l);
                mesh.position.set(-8 + (i * 1.8), 5.3, -4);
                mesh.userData = { def: { type: 'liquid', ...l }, originalPos: mesh.position.clone() };
                scene.add(mesh);
                chemicals.push(mesh);
            });
        }

        function createSolidContainer(def) {
            const container = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16),
                new THREE.MeshStandardMaterial({ color: 0x555555, transparent: true, opacity: 0.5 })
            );
            
            let geo;
            if(def.shape === 'chunk') geo = createChunkGeometry();
            else if(def.shape === 'ribbon') geo = createRibbonGeometry();
            else if(def.shape === 'nail') geo = createNailGeometry();
            else if(def.shape === 'wire') geo = createWireGeometry();
            else if(def.shape === 'granule') geo = createGranuleGeometry();
            else geo = createChunkGeometry();

            const mat = new THREE.MeshStandardMaterial({ 
                color: def.color, 
                roughness: 0.4, 
                metalness: 0.6 
            });
            const elem = new THREE.Mesh(geo, mat);
            elem.position.y = 0;
            if(def.shape === 'nail') { elem.rotation.x = Math.PI/2; elem.position.y = 0.1; }
            container.add(elem);

            const lbl = createLabel(def.label);
            lbl.position.set(0, 0, 0.55);
            container.add(lbl);

            return container;
        }

        function createLiquidBottle(def) {
            const group = new THREE.Group();
            
            // Bottle Glass
            const glass = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.5, 1.2, 16),
                new THREE.MeshPhysicalMaterial({ 
                    color: 0xffffff, transparent: true, opacity: 0.3,
                    roughness: 0.1, metalness: 0
                })
            );
            group.add(glass);

            // Liquid Inside
            const liquidMat = new THREE.MeshPhysicalMaterial({ 
                color: def.color, 
                transparent: def.opacity < 1.0, 
                opacity: def.opacity,
                metalness: def.metallic ? 1.0 : 0.0,
                roughness: def.metallic ? 0.1 : 0.2,
                transmission: def.metallic ? 0 : 0.6
            });
            
            const liquid = new THREE.Mesh(
                new THREE.CylinderGeometry(0.45, 0.45, 0.9, 16),
                liquidMat
            );
            liquid.position.y = -0.1;
            group.add(liquid);

            // Cap
            const cap = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.2, 0.3, 16),
                new THREE.MeshStandardMaterial({ color: 0x222222 })
            );
            cap.position.y = 0.75;
            group.add(cap);

            const lbl = createLabel(def.label);
            lbl.position.set(0, 0, 0.55);
            group.add(lbl);

            return group;
        }

        function createBoy() {
            const group = new THREE.Group();
            const skin = new THREE.MeshLambertMaterial({ color: 0xffdbac });
            const cloth = new THREE.MeshLambertMaterial({ color: 0x3498db });
            const goggles = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.2 });

            // Head
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.9, 0.8), skin);
            head.position.y = 3.8;
            group.add(head);
            
            // Safety Goggles
            const gog = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.25, 0.1), goggles);
            gog.position.set(0, 3.9, 0.45);
            group.add(gog);

            // Torso
            const torso = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 0.6), cloth);
            torso.position.y = 2.8;
            group.add(torso);
            // Arms
            const armL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.2, 0.3), skin);
            armL.position.set(-0.7, 2.8, 0);
            group.add(armL);
            const armR = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.2, 0.3), skin);
            armR.position.set(0.7, 2.8, 0);
            group.add(armR);

            group.position.set(-8, 0, 2);
            group.rotation.y = Math.PI / 4;
            scene.add(group);
            return { mesh: group, defaultPos: group.position.clone() };
        }

        // --- INTERACTION ---

        function onMouseDown(event) { handleInput(event.clientX, event.clientY); }
        function onTouchStart(event) { handleInput(event.changedTouches[0].clientX, event.changedTouches[0].clientY); }

        function handleInput(x, y) {
            if (isReacting || activeAnimation) return;
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(chemicals, true);
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while (obj.parent && !obj.userData.def) obj = obj.parent;
                if (obj.userData.def) startAnimation(obj);
            }
        }

        function startAnimation(obj) {
            isReacting = true;
            const def = obj.userData.def;
            if (def.type === 'liquid') animatePourLiquid(obj);
            else if (def.type === 'solid') animateDropSolid(obj);
        }

        function animatePourLiquid(obj) {
            const startPos = obj.userData.originalPos;
            const pourPos = new THREE.Vector3(1.8, 5.5, 0); // Side of beaker
            
            const seq = [
                { t: 0, p: startPos, r: 0 },
                { t: 1000, p: pourPos, r: 0 },
                { t: 1500, p: pourPos, r: -Math.PI / 2.5 },
                { t: 3000, p: pourPos, r: -Math.PI / 2.5 },
                { t: 3500, p: pourPos, r: 0 },
                { t: 4500, p: startPos, r: 0 }
            ];
            
            runAnimation(obj, seq, (time) => {
                if (time >= 1500 && time < 3000) {
                    if (!pourStreamMesh) {
                        const geo = new THREE.CylinderGeometry(0.05, 0.05, 2.5, 8);
                        const mat = new THREE.MeshBasicMaterial({ color: obj.userData.def.color, transparent: true, opacity: 0.6 });
                        pourStreamMesh = new THREE.Mesh(geo, mat);
                        pourStreamMesh.position.set(1.4, 4.5, 0);
                        pourStreamMesh.rotation.z = -0.2;
                        scene.add(pourStreamMesh);
                    }
                    liquidMesh.visible = true;
                    // Mix colors if liquid already exists
                    if (liquidMesh.scale.y > 0) {
                        liquidMesh.material.color.setHex(obj.userData.def.color);
                    } else {
                        liquidMesh.material.color.setHex(obj.userData.def.color);
                        liquidMesh.material.metalness = obj.userData.def.metallic ? 1.0 : 0.0;
                    }
                    liquidMesh.scale.y = Math.min(liquidMesh.scale.y + 0.015, 2.0);
                } else {
                    if (pourStreamMesh) { scene.remove(pourStreamMesh); pourStreamMesh = null; }
                }
            }, () => addToBeaker(obj.userData.def));
        }

        function animateDropSolid(obj) {
            const startPos = obj.userData.originalPos;
            const dropPos = new THREE.Vector3(0, 6, 0);
            
            const seq = [
                { t: 0, p: startPos },
                { t: 1000, p: dropPos },
                { t: 1500, p: dropPos },
                { t: 2500, p: startPos }
            ];

            let dropped = false;
            runAnimation(obj, seq, (time) => {
                if (time > 1200 && !dropped) {
                    dropped = true;
                    const def = obj.userData.def;
                    // Clone geometry for dropping
                    let geo;
                    if(def.shape === 'nail') geo = createNailGeometry();
                    else if(def.shape === 'ribbon') geo = createRibbonGeometry();
                    else geo = createChunkGeometry();
                    
                    const mat = new THREE.MeshStandardMaterial({ color: def.color });
                    dropMesh = new THREE.Mesh(geo, mat);
                    dropMesh.position.set(0, 6, 0);
                    scene.add(dropMesh);
                }

                if (dropMesh) {
                    dropMesh.position.y -= 0.15;
                    dropMesh.rotation.x += 0.1;
                    dropMesh.rotation.z += 0.1;
                    const limit = liquidMesh.scale.y > 0 ? 2.06 + liquidMesh.scale.y : 2.06;
                    if (dropMesh.position.y < limit) {
                        scene.remove(dropMesh);
                        dropMesh = null;
                        addToBeaker(obj.userData.def);
                    }
                }
            });
        }

        function runAnimation(obj, keyframes, onUpdate, onComplete) {
            const startTime = performance.now();
            const duration = keyframes[keyframes.length - 1].t;
            activeAnimation = {
                update: () => {
                    const now = performance.now();
                    const elapsed = now - startTime;
                    if (elapsed >= duration) {
                        if (onComplete) onComplete();
                        activeAnimation = null;
                        return;
                    }
                    let i = 0; while (keyframes[i+1].t < elapsed) i++;
                    const k1 = keyframes[i]; const k2 = keyframes[i+1];
                    const alpha = (elapsed - k1.t) / (k2.t - k1.t);
                    obj.position.lerpVectors(k1.p, k2.p, alpha);
                    if (k1.r !== undefined && k2.r !== undefined) obj.rotation.z = k1.r + (k2.r - k1.r) * alpha;
                    if (onUpdate) onUpdate(elapsed);
                }
            };
        }

        // --- REACTION LOGIC ---

        function addToBeaker(def) {
            beakerContents.push(def.name);
            checkReaction();
            if(!activeAnimation) isReacting = false;
        }

        function checkReaction() {
            const has = (n) => beakerContents.includes(n);
            const contents = beakerContents;
            let type = null;

            // Group definitions
            const alkali = ['Na', 'K', 'Li'];
            const reactive = ['Mg', 'Na', 'Zn', 'Fe', 'Al', 'Ca'];
            const acids = ['HCl', 'H2SO4', 'HNO3'];
            const bases = ['NaOH', 'KOH', 'NH3'];

            // 1. Alkali + Water
            if (has('H2O') && contents.some(c => alkali.includes(c))) type = 'explosion';
            
            // 2. Reactive Metal + Acid
            else if (contents.some(c => reactive.includes(c)) && contents.some(c => acids.includes(c))) type = 'bubbles';
            
            // 3. Acid + Base
            else if (contents.some(c => acids.includes(c)) && contents.some(c => bases.includes(c))) type = 'steam';
            
            // 4. Mercury
            else if (has('Hg') && contents.length === 1) type = 'heavy_liquid';

            if (type && type !== 'heavy_liquid') {
                const txt = document.getElementById('reaction-text');
                let msg = "";
                if(type === 'explosion') msg = "DhamakaðŸ’¥";
                if(type === 'bubbles') msg = "H2 GAS BUBBLES";
                if(type === 'steam') msg = "NEUTRALIZATION";
                
                txt.innerText = msg;
                txt.classList.add('show-text');
                triggerEffect(type);
                
                // CALL GEMINI FOR ANALYSIS
                const ingredients = [...beakerContents]; // Copy before reset
                analyzeReaction(ingredients, type);

                beakerContents = []; // Reset reaction state
                setTimeout(() => {
                    txt.classList.remove('show-text');
                    if(type === 'explosion') liquidMesh.scale.y = 0;
                    isReacting = false;
                }, 2500);
            } else {
                isReacting = false;
            }
        }

        function emptyBeaker() {
            beakerContents = [];
            liquidMesh.scale.y = 0;
            liquidMesh.visible = false;
            liquidMesh.material.metalness = 0;
            isReacting = false;
            boyCharacter.mesh.rotation.x = 0;
            boyCharacter.mesh.position.copy(boyCharacter.defaultPos);
            document.getElementById('reaction-text').classList.remove('show-text');
            showAIBubble("Beaker clean! Ready for new experiments.");
        }

        function triggerEffect(type) {
            // Play the custom sound file immediately
            playSoundEffect(type);

            if (type === 'explosion') {
                boyCharacter.mesh.rotation.x = -0.5; 
                boyCharacter.mesh.position.y = -1;
                createExplosion(0xffaa00, 60);
            } else if (type === 'bubbles') {
                createBubbles();
            } else if (type === 'steam') {
                createSmoke(0xeeeeee);
            }
        }

        // --- PARTICLES ---

        function createExplosion(color, count) {
            const geo = new THREE.DodecahedronGeometry(0.2);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            for(let i=0; i<count; i++) {
                const p = new THREE.Mesh(geo, mat);
                p.position.set(0, 3.5, 0);
                p.userData = {
                    vel: new THREE.Vector3((Math.random()-0.5), Math.random(), (Math.random()-0.5)).multiplyScalar(0.4),
                    life: 60
                };
                scene.add(p);
                particles.push(p);
            }
        }

        function createBubbles() {
            const geo = new THREE.SphereGeometry(0.08, 4, 4);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            for(let i=0; i<40; i++) {
                const p = new THREE.Mesh(geo, mat);
                p.position.set((Math.random()-0.5)*1.2, 2.2, (Math.random()-0.5)*1.2);
                p.userData = { vel: new THREE.Vector3(0, 0.08, 0), life: 100 };
                scene.add(p);
                particles.push(p);
            }
        }

        function createSmoke(color) {
            const geo = new THREE.SphereGeometry(0.3, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.4 });
            for(let i=0; i<50; i++) {
                const p = new THREE.Mesh(geo, mat);
                p.position.set(0, 3.5, 0);
                p.userData = { vel: new THREE.Vector3((Math.random()-0.5)*0.1, 0.05, (Math.random()-0.5)*0.1), life: 150, grow: true };
                scene.add(p);
                particles.push(p);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (activeAnimation) activeAnimation.update();

            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.position.add(p.userData.vel);
                if (p.userData.grow) {
                    p.scale.multiplyScalar(1.01);
                    p.material.opacity -= 0.005;
                } else {
                    p.userData.life--;
                }
                if (p.userData.life <= 0 || p.material.opacity <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            if (!activeAnimation && !isReacting) {
                boyCharacter.mesh.rotation.x *= 0.95;
                boyCharacter.mesh.position.lerp(boyCharacter.defaultPos, 0.05);
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
